# 对象的共享

## 对象或变量的可见性

#### 可见性

​		当一个线程修改了对象（变量）的状态（值）后，其他线程能够看到状态发生的变化。



#### 失效数据

​		若对象或变量在不同的线程中共享，且对象的状态或变量的值被某一个线程改变，但其他线程在读取时，并不会读取到最新的值，而是数据被修改之前的值，此时读取到的数据就是**失效数据**。

​		

#### Synchronized与volatile

​		Synchronized不仅可以对变量实现同步，也可以实现内存的可见性。

​		volatile可以只可以实现内存的可见性，不能对变量实现同步，相对Synchronized来说更加轻量级。

​		volatile虽然更加轻量级，但不能滥用。应仅当在volatile能简化代码实现时或对同步策略的验证时使用，即在以下情况使用：

> 1. 确保对象自身状态的可见性
> 2. 确保变量多引用对象的状态的可见性
> 3. 标识一些重要的程序生命周期事件的发生

​		volatile可以使用的条件：

> 1. 对变量的写入操作不依赖变量的当前值，或能确保只有单个线程更新变量
> 2. 该变量不会与其他状态变量一起纳入不变性条件中
> 3. 在访问变量时不需要加锁



## 发布与溢出

​		发布：发布一个对象指的是，使对象能够在当前作用域之外的代码中使用。

​		逸出：当某个不应该发布的对象被发布时，就叫作逸出。

​		对象发布的方法：

> 1. 将对象的引用保存到一个公有的静态变量中
> 2. 将对象的引用传递到非对象所属类中的方法
> 3. 在构造函数中创建一个新的线程

​		在第三种情况中，this引用会逸出到新的线程中，在运行新的线程时，此对象可能还未构造完成，就可能会出错。

若必须要i在构造函数中创建新的线程，可以先不调用.start()方法，对象创建完成后再调用。



## 线程封闭

​		如果仅在单线程内访问数据，就不需要使用同步，这种技术被称为线程封闭，这是实现线程安全性的最简单方式之一。



#### Ad-hoc线程封闭

​		Ad hoc是拉丁文常用短语中的一个短语。这个短语通常用来形容一些特殊的、不能用于其它方面的的，为一个特定的问题、任务而专门设定的解决方案。所以此种线程封闭完全由程序的实现者来手动根据具体情况来实现。



#### 栈封闭

​		在一个方法中创建对象，并且不返回这个对象的引用，这时这个对象就被封闭在一个线程中，其他线程不可获取。若在一个方法中创建一个基本类型的变量，即使在方法最后返回了这个变量，也不会造成逸出，因为基本类型的引用无法获取，只是值在传递。因为一个方法开始运行时，此方法的栈帧会进入 Java 虚拟机栈，在栈帧中有局部变量表保存着局部变量，所以叫做栈封闭 。 



#### Threadlocal类

​		如果创建了一 个ThreadLocal 变量 ，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。

```java
public class ThreadLocalTest {

    // 创建一个 ThreadLocal
    static ThreadLocal<String> localVariable = new ThreadLocal<>();

    public static void main(String[] args) {
        Thread threadOne = new Thread(
                () -> {
                    // 设置变量，threadTwo无法获取
                    localVariable.set("threadOne local variable");
                    // 获取变量
                    System.out.println(localVariable.get());
                    // 删除变量
                    localVariable.remove();
                }
        );

        Thread threadTwo = new Thread(
                () -> {
                    // 设置变量，threadOne无法获取
                    localVariable.set("threadTwo local variable");
                    System.out.println(localVariable.get());
                    localVariable.remove();
                }
        );

        threadOne.start();
        threadTwo.start();
    }
}
```

> 1. 一个 ThreadLocal实例在一个线程中只能保存一个变量。
> 2. 一个 ThreadLocal实例可以存在多个线程中，但每个线程中此 ThreadLocal实例可以获取的值并不同。
> 3. 一个线程中可以有多个 ThreadLocal实例，存储多个线程本地变量。
> 4. ThreadLocal类不支持继承，同一个 ThreadLocal实例，在父线程中设置值之后，在子线程中是获取不到的。





## 不变性

​		具有不变性的对象很简单，此种对象只有一种状态，并且该状态有构造函数来控制。

​		当满足以下条件时，对象才是不可变的：

> 1. 对象创建后其状态不能修改
> 2. 对象的所有域都是 final 类型
> 3. 对象是正确创建的（this没有溢出）

​		即使对象中所有的域都是 final类型的，这个对象仍是可变的，因为在final类型的域中可以保存可变对象的引用。

​		每当需要一对相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据，这样就不会有其他的线程修改这些数据。如果要更新这些变量，那么可以创建一个新的容器对象。在使用不可变对象的同时，可以使用 volatile来修饰不可变对象的引用变量，确保可见性，使所有线程都可以获得最新的对象引用。



## 安全发布

#### 不可变对象

​		不可变对象的域都是 final 类型，并且有正确的构造过程。即使在发布不可变对象的引用时没有使用同步，也仍然可以安全访问该对象，因为该对象的所有域都不可改变。可以使用**任何方式来发布对象**。



#### 事实不可变对象

​		如果从技术上来看是可变的，但其状态在发布后不会再改变，这种对象称为事实不可变对象。与不可变对象不同的是，并不要求所有域都是 final 类型，但却可以安全访问该对象，这是因为在程序的代码中，并不会修改此对象。但事实不可变对象的发布**必须要使用安全的方式发布**，因为对象的引用可能会变。



#### 可变对象

​		可变对象必须通过安全的方式发布，并且必须是线程安全的或者由某个锁保护起来。



#### 可变对象的发布

​		最简单的发布一个对象，从而使其能被多个线程使用的方法就是在公有域创建一个对象的引用，但此种方法并不安全。因为对象状态对于使用该对象的线程来说不一定是可见的（某个对象或对象中的某个被访问到的字段会被放到线程的工作内存中），所以就会导致各个线程读取到的发布对象的引用不同，即使引用相同，对象中的字段可能也不同。

​		所以要用其他安全的方式发布，具体的方法如下：

1. **在静态初始化函数中初始化一个对象引用**

   ​		静态初始化器由 JVM在类的初始化阶段执行，由于在 JVM 内部存在着同步机制，因此可以被安全的发布。

2. **将对象的引用保存到 volatile 类型的域或者 AtomicReferance 中**

3. **将对象的引用保存到某个正确构造对象的final类型域中**

   ​		被 final修饰后，变量指向的引用就不可变。

4. **将对象的引用保存到一个由锁保护的域中**

   - 若要发布键值对，则可以用 Hashtable，synchronizedMap 或 ConcurrentMap
   - 若要保存到列表或集合中，则可以用 Vector，CopyOnWriteArrayList，CopyOnWriteArraySet，synchronizedList 和synchronizedSet。
   - 若要保存到队列中，则可以用 BlockingQueue 或 ConcurrentLinkedQueue 中

























