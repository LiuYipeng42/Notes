# Java堆中对象的创建



### 1. 类加载检查

​		当Java创建一个对象时，首先将去检查这个指令的参数**是否能在常量池中定位到一个类的符号引用**，并且**检查这个符号引用代表的类是否已被加载、解析和初始化过**。如果没有，那必须先**执行相应的类加载过程**。



### 2. 分配内存

​		对象所需内存的大小在类加载完成后便可完全确定，分配内存等于把一块确定大小的内存块从Java堆中划分出来。

#### 		内存分配方式

​		如果Java堆中的内存**并不是规整的**，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就**必须维护一个列表，记录上哪些内存块是可用的**，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为**空闲列表**。

​		假设Java堆中内存是**绝对规整的**，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是**把那个指针向空闲空间方向挪动一段与对象大小相等的距离**，这种分配方式称为**指针碰撞。**

​		Java堆**是否规整**由所采用的垃圾收集器是否带有**空间压缩整理**（Compact）的能力决定。

#### 		多线程指针碰撞分配内存

​		当多个线程同时为分配内存时，若使用指针碰撞，由于只有一个指针，则很容易会出错。此时用以下两种方式解决。

​		第一种，分配内存空间采用同步处理。虚拟机是采用**CAS配上失败重试**的方式保证更新操作的原子性。**CAS（Campare and Swap ）**，在计算数据前，存储要改变的数据的值，在计算完后更新数据时，比较存储的原值与原来的值是否相当，即Campare，然后若两者相等，即原来的值没有被另一个线程改变，则用新的数据替换旧数据，即Swap。

​		第二种，每个线程在Java堆中**预先分配一小块内存**，称为**本地线程分配缓冲**（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在这个线程的本地缓冲区中分配，只有本地缓冲区用完了，**分配新的缓存区时才需要同步锁定**。



### 3. 数值初始化

​		分配内存之后，虚拟机必须将分配到的**内存空间**（但不包括对象头）都**初始化为零值**。若使用了**TLAB**，项工作也可以提前至**TLAB分配时顺便进行**。

​		这可以保证**没有赋初值的变量**的值是对应数据类型的**零值**。



### 4. 设置对象头

​		对象头（Object Header）中的内容包括以下内容，这个对象是**哪个类的实例**、如何才能**找到类的元数据信息**、对象的**哈希码**（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、**对象的GC分代年龄**等信息。根据虚拟机当前运行状态的不同，如**是否启用偏向锁**等，对象头会有不同的设置方式。



### 5. 利用构造函数初始化对象

​		一般来说（由字节码流中new指令后面**是否跟随invokespecial指令**所决定，Java编译器会在遇到new关键字的地方**同时生成这两条字节码指令**，但如果直接通过其他方式产生的则不一定如此），**new指令之后会接着执行\<init>()方法**，按照程序员的意愿**对对象进行初始化**，这样一个真正可用的对象才算完全被构造出来。









