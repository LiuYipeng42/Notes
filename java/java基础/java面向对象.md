---
title: java面向对象 
date: ‎2021-0‎1‎-25
description: java面向对象的封装，多态和继承
---

## 面向对象的三部分

1.封装

2.继承

3.多态



## 封装

1. 修改属性的可见性来限制对属性的访问（一般限制为private）

2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问

```java
public class User {
    // 将变量设为private就是封装
    private int age;
    private String name;
	
    // 若要对封装的变量进行读取和修改就要使用get和set方法，
    // 可以在Interllj中右键添加
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if(0 > age || age > 150){
            return;
        }
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```



### 构造器

构造器方法与普通方法的区别是构造器方法**没有返回值类型**，两者都支持**方法重载**。

当一个类没有构造器时，会自动生成一个没有参数的**缺省构造器**，

不管类中有没有构造器，最好都创建一个**无参数构造器**

即使在构造器中没有写代码主动给属性赋值，java也会**给属性赋一个初始值**





### 空指针异常

空引用访问实例相关的数据，因为实例相关的数据就是对象相关的数据，这些数据在访问的时候，必须有对象的参与，当空引用的时候，对象不存在，访问这些实例数据一定会出现空指针异常。

实例相关的数据包括:

实例变量【对象需要存在】

实例方法【对象需要存在】

不相关的数据包括

静态变量【对象不需要存在】

静态方法【对象不需要存在】





## 继承

- 继承的**作用**是:

  1.代码复用。

  2.有了继承才有了以后”方法的覆盖"和”多态机制

- 继承**语法格式**:

  [修饰符列表] class 类名 extends父类名(

  ​	类体=属性+方法

  }

- java语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类。

- 关于继承中的一些**术语**:

  B类继承A类,其中:

  A类称为：父类、基类、超类、superclass

  B类称为：子类、派生类、subclass

- **继承规则**

  私有的不支持继承，构造方法不支持继承，其它数据都可以被继承

  私有的变量虽然不能继承，但是可以通过继承的方法访问这些私有的变量

- 虽然java语言当中只支持单继承，但是一个类也可以**间接继承其它类**。

- 如果一个类没有显示的继承任何类，该类默认继承JavaSE库当中提供的java.lang.Object类。

  java语言中任何类中都有Object类的特征。



### 方法覆盖

方法覆盖又被称为方法重写，英语单词：**override/overwrite** 

- 方法覆盖的**使用情景**： 

  ​		当父类中的方法已经无法满足当前子类的业务需求，子类有必要将父类中继承过来的方法进行重新编写， 这个重新编写的过程称为方法重写／方法覆盖。

- 方法覆盖的**要求**：

  1. 方法重写发生在具有继承关系的父子类之间 

  2. 返回值类型相同，方法名相同，形参列表相同 

  3. **访问权限**不能更低，可以更高
  4. 触发**异常**不能更多，可以更少

-  **不能覆盖**的内容
  1. **私有方法**不能继承，所以不能覆盖
  2. **构造方法**不能继承，所以不能覆盖
  3. **静态方法**不存在覆盖
  4. 覆盖只针对方法，**属性**不能覆盖



## 多态

### **向上转型（upcasting）**

**子类型**转换到**父类型**，又被称为自动类型转换。

若new (创建) 一个子类，并将其声明为父类类型。如下所示：

```
父类类型 对象名 = new 子类(参数);
```

java程序运行分为**编译阶段**和**运行阶段**。

​		在**编译阶段**，编译器会先检查出这个对象的数据类型为父类类型。此时，由于子类继承父类，当使用此对象的**继承父类的方法**时，编译通过，因为父类有这些方法。这个过程称为**静态绑定**，编译阶段绑定，只有静态绑定成功之后才有后续的运行。但不可以使用子类中**非继承的方法**，因为编译器认为此对象是父类类型的对象，编译器在父类中找不到这些方法，此时静态绑定就不会成功，编译不通过。
​		在**运行阶段**，JVM堆内存当中真实创建的对象是子类对象，那么程序在运行阶段一定会调用子类对象所继承或重写父类的方法，而不是直接使用父类的方法，此时发生了程序的**动态绑定**，运行阶段绑定。所以此时，若在子类中将从父类中继承的方法重写，运行的会是子类中重写的方法。

​		所以，在子类型转换的父类型时，子类可以调用从父类中继承的方法，这些方法可以重写，当使用这些方法时，运行的会是子类中继承的或重写的方法，而不是父类的方法。不可以使用子类特有的其他方法。

​		父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定两种不同的形态/状态。即，在第一个阶段，子类对象被编译器认为是父类类型的对象，而在第二个阶段，运行子类对象的方法却是子类的代码。这种机制可以成为一种多态语法机制。称为**多态**。



### **向下转型（douwncasting）**

**父类型**转换到**子类型**，又被称为强制类型转换，需要**加强制类型转换符**。

无论是向上转型还是向下转型，两种类型之间必须要有继承关系。



#### ClassCastException异常

```java
Father a = new Child1();
Child1 b = (Child1)a;
Child2 c = (Child2)a;
```

以上程序编译没有问题，因为父类型与两个子类型都有继承关系，父类型转换成子类型叫做向下转型，语法合格，编译通过。

程序虽然编译通过了，但是程序在运行阶段会出现异常，在第三行会出现**ClassCastException类型转换异常**，因为JVM堆内存当中真实存在的对象是Child1类型，Child1对象无法转换成Child2对象，因为两种类型之间不存在任何继承关系，此时出现了著名的异常：java.lang.ClassCastException类型转换异常，这种异常总是在“向下转型”的时候会发生。

在对象进行向下转型时，必须首先发生对象向上转型，否则将出现对象转换异常

#### instanceof

ClassCastException类型转换异常可以利用instanceof语法来避免

```java
Father a = new Child1();
if(a instanceof Child1){
	Child1 b = (Child1)a;
}
if(b instanceof Child2){
	Child2 c = (Child2)b;
}
```





